\section{Task2}
\subsection{Estimating Size of Union of Two Set}
Suppose Alice and Bob each has a set of element $s^a = (e^a_1,...,e^a_n)$
and $s^b = (e^b_1,...,e^b_n)$. The problem we want to solve is 
to compute $|s^a\cup s^b|$. Here, we introduce two algorithms:

\paragraph{Using oblivious sort and oblivious merge}
A straightforward way of calculating the union is two use oblivious sorting, as detailed in the following:

\begin{algorithm}[t]
\begin{algorithmic}[1]
\State sort the input array $d[]$ obliviously.
\State $cnt = 1$
\For {$i=0:len(d)-1$}
	\If{$d[i] != d[i+1]$}
		\State $cnt = cnt + 1$
	\EndIf
\EndFor
\State\Return $cnt$
\end{algorithmic}
\caption{\textbf{Compute size of union}} %\\
\label{alg:osssp}
\end{algorithm}
For $n$ elements each of bitlength $D$, this approach requires a circuit of size $O(Dn\log^2n)$ using bitonic sorting network,
and can be further reduced to $Dn\log n$ if each part sort their data locally and only perform an bitonic merge using secure computation.

\paragraph{Using bloom filter}
It is known that bloom filters can be used to check the existence of an element in a set. However, bloom filters can also be used
to estimate the capacity of a set. Let $X$ be the number of bits set as one, $m$ be the total number of bits used in the bloom filter and
$k$ be the number of hash functions used. The size of a bloom filter can be estimated as 
$$-\frac{m\ln(1-\frac{X}{m})}{k}.$$
So, if we would like to compute the union of two set, each party can first build their own bloom filter locally using same set of hash functions
and then, in secure computation, the two parties first union the bloom filter by bitwise or, and then count number of ones appeared in the new bit array.
Note that after getting X, the remaining part of the computation can  be done in cleartext. Using bloom filter, we can compute the size of union using $O(n\lambda)$
number of gates, regardless of the bitlength.
\subsection{Task2a, Hamming Distance}
The website simplify the definition of hamming distance and can be computed easily given the functionality mentioned above.
Let's define an record contains the associated position and the value in a form of $(pos, val)$. Each party holds a set of records like this, namely 
$S^a$ and $S^b$. The hamming distance is equivalent to $|S^a\cup S^b| - |S^a\cap S^b|$, that is the sum of number of elements not shared by two parties.
Note that $|S^a\cup S^b| - |S^a\cap S^b| = 2\times|S^a\cup S^b|-|S^a| - |S^b|$. So we can use the aforementioned algorithms to compute hamming distance.

Note that in order to use oblivious sort, each record has to has the same bitlength. Instead of padding every record to the maximum possible length, we hash each
record to a fixed length bit string.
\subsection{Task2b, Edit Distance}
Edit distance can also be reduce to calculating size of certain set. First, we compute {\tt d1} defined as follows similarly to the definition on website:\\
{\tt
d1 = 0;\\
for every pos in VCF files:\\
if there are two records x, y at pos,

d1 += max(D(x), D(y))\\
else if there is only one record at pos,

d1+=D(x)\\}

In order to compute {\tt d1}, for every record $(pos, val)$, each party insert $(pos, i), i\in[1, len(val)]$ to the set and get set $S_1^a, S_1^b$. Then is 
can be seen that ${\tt d1} = |S_1^a\cup S_1^b|$.

Now, let's define ${\tt d2}$ as follows:
{\tt
d2 = 0;\\
for every pos in VCF files:\\
if there are two records x, y at pos and they are same,

d2 += D(x)\\}
In order to compute {\tt d2}, the two parties construct two new set: For every record $(pos, val)$, each party insert $(pos,val, i), i\in[1, len(val)]$ to the set and get set $S_2^a, S_2^b$. Then is 
can be seen that ${\tt d2} = |S_2^a\cap S_2^b|$.

After we define {\tt d2} and {\tt d1}, it is clear and {\tt d = d1-d2}