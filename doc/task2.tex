\section{Task2}
\subsection{Estimating Size of Union of Two Sets}
Before going into how to solve Task2, we first present the solution to estimated the size of union of two sets.
Suppose Alice and Bob each has a set of element $s^a = (e^a_1,...,e^a_n)$
and $s^b = (e^b_1,...,e^b_n)$. The problem we want to solve is 
to compute $|s^a\cup s^b|$. Here, we introduce two algorithms:

\paragraph{Using oblivious sort and oblivious merge}
A straightforward way of calculating the union is two use oblivious sorting, as detailed in Algorithm~\ref{alg1}

\begin{algorithm}
\begin{algorithmic}[1]
\State sort the input array $d[]$ obliviously.
\State $cnt = 1$
\For {$i=0:len(d)-1$}
	\If{$d[i] != d[i+1]$}
		\State $cnt = cnt + 1$
	\EndIf
\EndFor
\State\Return $cnt$
\end{algorithmic}
\caption{\textbf{Compute size of union}} %\\
\label{alg1}
\end{algorithm}
For $n$ elements each of bitlength $D$, this approach requires a circuit of size $O(Dn\log^2n)$ using bitonic sorting network,
and can be further reduced to $O(Dn\log n)$ if each part sort their data locally and only perform an bitonic merge using secure computation.
In the submission, we take the second approach that is much faster than sorting.
\paragraph{Code used for oblivious merge.}
Here we also include the code used for oblivious merge in written in {\tt ObliVM-lang}.
\begin{figure}[H]
\begin{tabular}{rl}
\small 1&\small \tt \struct Task2Automated\at{m}\at{n}\{\};\\

\small 2&\small \tt int\at{n} Task2Automated\at{m}\at{n}.\func{funct}(int\at{m}[\public 1] key, \public int32 length) \{\\
\small 3&\small \tt \quad this.\func{obliviousMerge}(key, 0, length);\\
\small 4&\small \tt  \quad int\at{n} ret = 1;\\
\small 5&\small \tt  \quad \for(\public int32 i = 1; i < length; i = i + 1) \{\\
\small 6&\small \tt  \quad\quad     \ifs(key[i-1] != key[i])\\
\small 7&\small \tt        \quad\quad\quad  ret = ret + 1;\\
\small 8&\small \tt    \quad\}\\
\small 9&\small \tt    \quad \return ret;\\
\small 10&\small \tt \}\\
\small 11&\small \tt void Task2Automated\at{m}\at{n}.\func{obliviousMerge}(int\at{m}[\public 1] key, \public int32 lo, \public int32 l) \{\\
\small 12&\small \tt   \quad \ifs (l > 1) \{\\
\small 13&\small \tt     \quad\quad  \public int32 k = 1;\\
\small 14&\small \tt    \quad\quad   \while (k < l) k = k << 1;\\
\small 15&\small \tt     \quad\quad\quad  k = k >> 1;\\
\small 16&\small \tt    \quad\quad\quad   \for (\public int32 i = lo; i < lo + l - k; i = i + 1)\\
\small 17&\small \tt     \quad\quad\quad\quad     this.\func{compare}(key, i, i + k);\\
\small 18&\small \tt     \quad\quad\quad  this.\func{obliviousMerge}(key, lo, k);\\
\small 19&\small \tt     \quad\quad\quad  this.\func{obliviousMerge}(key, lo + k, l - k);\\
\small 20&\small \tt   \quad\}\\
\small 21&\small \tt \}\\


\small 22&\small \tt void Task2Automated\at{m}\at{n}.\func{compare}(int\at{m}[\public 1] key, \public int32 i, \public int32 j) \{\\
\small 23&\small \tt  \quad  int\at{m} tmp = key[j];\\
\small 24&\small \tt  \quad  int\at{m} tmp2 = key[i];\\
\small 25&\small \tt \quad   \ifs( key[i] < key[j] )\\
\small 26&\small \tt   \quad\quad    tmp = key[i];\\
\small 27&\small \tt  \quad  tmp = tmp  key[i];\\
\small 28&\small \tt \quad   key[i] = tmp key[j];\\
\small 29&\small \tt \quad   key[j] = tmp  tmp2;\\
\small 30&\small \tt \}\\
\end{tabular}
\end{figure}


\paragraph{Using bloom filter}
It is known that bloom filters can be used to check the existence of an element in a set. However, bloom filters can also be used
to estimate the capacity of a set. Let $X$ be the number of bits set as one, $m$ be the total number of bits used in the bloom filter and
$k$ be the number of hash functions used. The size of a bloom filter can be estimated as 
$$-\frac{m\ln(1-\frac{X}{m})}{k}.$$
So, if we would like to compute the union of two sets, each party can first build their own bloom filter locally using the same set of hash functions
and then, in secure computation, the two parties first union the bloom filter by bitwise or, and then count number of ones appeared in the new bit array,
which is $X$ mentioned above.
Note that after getting X, the remaining part of the computation can  be done in cleartext. Using bloom filter, we can compute the size of union using $O(n\lambda)$
number of gates, regardless of the bitlength.
\subsection{Task2a, Hamming Distance}
The website simplify the definition of hamming distance, which can be computed easily given the functionality mentioned above.
Let's define an record contains the associated position and the value in a form of $(pos, val)$. Each party holds a set of records like this, namely 
$S^a$ and $S^b$. The hamming distance is equivalent to $|S^a\cup S^b| - |S^a\cap S^b|$, that is the sum of number of elements not shared by two parties.
Note that $|S^a\cup S^b| - |S^a\cap S^b| = 2\times|S^a\cup S^b|-|S^a| - |S^b|$. So we can use the aforementioned algorithms to compute hamming distance.

Note that in order to use oblivious sort, each record has to has the same bitlength. Instead of padding every record to the maximum possible length, we hash each
record to a fixed length bit string.
\subsection{Task2b, Edit Distance}
Edit distance can also be reduce to calculating size of certain set. First, we compute {\tt d1} defined as follows similarly to the definition on website:\\
{\tt
d1 = 0;\\
for every pos in VCF files:\\
if there are two records x, y at pos,

d1 += max(D(x), D(y))\\
else if there is only one record at pos,

d1+=D(x)\\}

In order to compute {\tt d1}, for every record $(pos, val)$, each party insert $(pos, i), i\in[1, len(val)]$ to the set and get set $S_1^a, S_1^b$. Then is 
can be seen that ${\tt d1} = |S_1^a\cup S_1^b|$.

Now, let's define ${\tt d2}$ as follows:
{\tt
d2 = 0;\\
for every pos in VCF files:\\
if there are two records x, y at pos and they are same,

d2 += D(x)\\}
In order to compute {\tt d2}, the two parties construct two new set: For every record $(pos, val)$, each party insert $(pos,val, i), i\in[1, len(val)]$ to the set and get set $S_2^a, S_2^b$. Then is 
can be seen that ${\tt d2} = |S_2^a\cap S_2^b|$.

After we define {\tt d2} and {\tt d1}, it is clear and {\tt d = d1-d2}