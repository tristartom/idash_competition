\section{Task 1}
\subsection*{Task 1a: Computing Minor Allele Frequencies}
\paragraph{Problem statement.}
~\\
Input for Alice: List of alleles $l^A = (e^A_1,...,e^A_n)$ where each $e^A_i$ is from $[A, T, C, G]$.\\
Input for Bob: List of alleles $l^B = (e^B_1,...,e^B_n)$.\\

The problem is to compute the 
Minor Allele Frequencies(MAF) over $l = l^A || l^B$. The definition of MAF is as follows:
Let $f_1$ and $f_2$ be the frequency of two types of alleles in $l$. MAF is defined to be as $min\{f_1, f_2\}$.

\paragraph{Our solution.}
The two parties first compute the frequency of two types of alleles of their own lists and get
$(f^A_1, f^A_2)$ for Alice and $(f^B_1,f^B_2)$ for Bob, ordered by allele type.
Then, in the secure computation, the two parties first sum up the frequency by
$$(f_1, f_2) = (f^A_1+f^A_1, f^B_2+f^B_2),$$
and then report the smaller number between $f_1$ and $f_2$.
\paragraph{Result.}
For this task, each test case requires only 40 AND gates for both manually generated circuits and automatically generated circuits.

%\paragraph{Code used for Task1a.}
The code used for this task is shown in Figure~\ref{fig:lang-circuit-oram}.
%Here we also include the code used for Task 1a written in {\tt ObliVM-lang}.
\begin{figure}[H]
\begin{tabular}{rl}
\small 1&\small \tt	\struct Task1aAutomated\at{m}\{\};\\
\small 2&\small \tt	void Task1aAutomated\at{m}.\func{funct}(int\at{m}[\public 1] alice\_data, int\at{m}[\public 1] bob\_data,\\
\small 3&\small \tt	\quad      int\at{m}[\public 1] ret, \public int\at{m} total\_instances, \public int32 test\_cases) \{\\
\small 4&\small \tt	\quad   int\at{m} total = total\_instances;\\
\small 5&\small \tt	  \quad int\at{m} half = total\_instances / 2;\\
\small 6&\small \tt	 \quad  \for(\public int32 i = 0; i < test\_cases; i = i + 1) \{\\
\small 7&\small \tt	     \quad\quad ret[i] = alice\_data[i] + bob\_data[i];\\
\small 8&\small \tt	     \quad\quad \ifs(ret[i] > half)\\
\small 9&\small \tt	         \quad\quad\quad ret[i] = total - ret[i];\\
\small 10&\small \tt	  \quad \}\\
\small 11&\small \tt\}\\
\end{tabular}
\caption{Code for Task 1a written in {\tt ObliVM-lang}}
\label{fig:lang-circuit-oram}
\end{figure}


\subsection*{Task 1b: Computing $\chi$ square statistics}
\paragraph{Problem statement.}
~\\
Input for Alice: two lists of alleles $l^A_{case} = (e^A_1,...,e^A_n)$, $l^A_{control} = (e^A_1,...,e^A_n)$\\
Input for Bob: two lists of alleles $l^B_{case} = (e^B_1,...,e^B_n)$, $l^B_{control} = (e^B_1,...,e^B_n)$\\

First define $a, b$ to be the frequency of two types of alleles in
$l_{case} = l^A_{case} || l^B_{case}$ and $c, d$ to be the frequency of two types of alleles in
$l_{control} = l^A_{control} || l^B_{control}$. The problem is to compute the Chi square statistics over $l = l^A||l^B$. This is defined as 
$$n\times\frac{(ad-bc)^2}{rsgk},$$
where $r = a + b, s = c + d, g = a + c, k = b + d, n =  r + s$; 


\paragraph{Our solution.}
Each party first locally computes the frequency of alleles on their own list: $a^A,b^A,c^A,d^A$ for Alice
and $a^B,b^B,c^B,d^B$ for Bob. $a^A,b^A$ are the frequency of two types of alleles in $l^A_{case}$ and 
$c^A,d^A$ are the frequency of two types of alleles in $l^A_{control}$. $a^B,b^B,c^B,d^B$  is defined similarly.
In the secure computation we first compute $a = a^A + a^B, b = b^A + b^B,
c = c^A + c^B,d = d^A + d^B$, then we evaluate the equation mentioned above directly using floating point
numbers.

\paragraph{Result.}
Our implementation for this task supports an arbitrary 
trade off between precision and speed. We mention two specific cases here.
For each test case, an implementation that requires 7763 AND gates achieves a maximum absolute error of $1.11\times10^{-4}$
 and an implementation with 14443 AND gates achieves a maximum absolute error of $5.6\times10^{-8}$.

The code used for this task is shown in Figure~\ref{fig:task1b}.
%\paragraph{Code used for Task1b.}
%Here we also include the code used for Task1b written in {\tt ObliVM-lang}.
\begin{figure}[H]
\begin{tabular}{rl}
\small 1&\small \tt \struct Task1bAutomated\at{n}\{\};\\
\small 2&\small \tt float32[\public n] Task1bAutomated\at{n}.\func{func}(\\
\small 3&\small \tt \quad      float32[\public n][\public 3] alice\_case, float32[\public n][\public 3] alice\_control,\\
\small 4&\small \tt  \quad     float32[\public n][\public 3] bob\_case, float32[\public n][\public 3] bob\_control) \{\\
\small 5&\small \tt \quad   float32[\public n] ret;\\
\small 6&\small \tt  \quad  \for(\public int32 i = 0; i < n; i = i + 1) \{\\
\small 7&\small \tt     \quad \quad  float32 a = alice\_case[i][0] + bob\_case[i][0];\\
\small 8&\small \tt     \quad \quad  float32 b = alice\_case[i][1] + bob\_case[i][1];\\
\small 9&\small \tt     \quad \quad  float32 c = alice\_control[i][0] + bob\_control[i][0];\\
\small 10&\small \tt    \quad \quad   float32 d = alice\_control[i][1] + bob\_control[i][1];\\
\small 11&\small \tt    \quad \quad   float32 g = a + c, k = b + d;\\
\small 12&\small \tt    \quad \quad   float32 tmp = a*d - b*c;\\
\small 13&\small \tt     \quad \quad  tmp = tmp*tmp;\\
\small 14&\small \tt     \quad \quad  ret[i] = tmp / (g * k);\\
\small 15&\small \tt   \quad  \}\\
\small 16&\small \tt  \quad  \return ret;\\
\small 17&\small \tt\}\\
\end{tabular}
\caption{Code for Task 1b written in {\tt ObliVM-lang}}
\label{fig:task1b}
\end{figure}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
