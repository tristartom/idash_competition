\section{Task1}
\subsection{Task1a, Computing Minor Allele Frequencies}
The problem of computing Minor Allele Frequencies(MAF) can be abstracted as follows:

Suppose Alice and Bob each has a list of alleles $l^a = (e^a_1,...,e^a_n)$ and $l^b = (e^b_1,...,e^b_n)$.
Let's append $l^b$ to $l^a$ and get $l = l^a || l^b$. It is known in public that in $l$, there will be at most two types of
alleles from $(A,T,C,G)$. We want to compute the frequency of allele in $l$ that appears less frequently.

\paragraph{Our Solution}
The two parties first aggregate their own input into two numbers: $(f^a_1, f^a_2)$ for Alice and $(f^b_1,f^b_2)$ for Bob, ordered by allele type.
Then, in the secure computation, the two parties first aggregate the frequency by
$$(f_1, f_2) = (f^a_1+f^a_1, f^b_2+f^b_2),$$
and then report the smaller number between $f_1$ and $f_2$

For this task, each test case only requires 40 AND gates for both manually generated circuits and automatically generated circuits.

\paragraph{Code used for Task1a.}
Here we also include the code used for Task1a written in {\tt ObliVM-lang}.
\begin{figure}[H]
\begin{tabular}{rl}
\small 1&\small \tt	\struct Task1aAutomated\at{m}\{\};\\
\small 2&\small \tt	void Task1aAutomated\at{m}.\func{funct}(int\at{m}[\public 1] alice\_data, int\at{m}[\public 1] bob\_data,\\
\small 3&\small \tt	\quad      int\at{m}[\public 1] ret, \public int\at{m} total\_instances, \public int32 test\_cases) \{\\
\small 4&\small \tt	\quad   int\at{m} total = total\_instances;\\
\small 5&\small \tt	  \quad int\at{m} half = total\_instances / 2;\\
\small 6&\small \tt	 \quad  \for(\public int32 i = 0; i < test\_cases; i = i + 1) \{\\
\small 7&\small \tt	     \quad\quad ret[i] = alice\_data[i] + bob\_data[i];\\
\small 8&\small \tt	     \quad\quad \ifs(ret[i] > half)\\
\small 9&\small \tt	         \quad\quad\quad ret[i] = total - ret[i];\\
\small 10&\small \tt	  \quad \}\\
\small 11&\small \tt\}\\
\end{tabular}
\label{fig:lang-circuit-oram}
\end{figure}


\subsection{Task1b, Computing $\chi$ square statistics}
The problem can be abstracted as follows:
The two parties want to compute the following results:
$$n\times\frac{(ad-bc)^2}{rsgk},$$
where $r = a + b, s = c + d, g = a + c, k = b + d, n =  r + s$; and $a,b,c,d$ are additively secret shared by two parties.

\paragraph{Our Solution}
On the high level, we take a direct approach: In secure computation, we first add shares from two parties and get $a,b,c,d,r,s,g,k$
and then convert it into floating point numbers securely, and finally compute the function mentioned above using floating
point numbers securely.

For this task, each test case only requires 7763 AND gates achieving maximum absolute error of $1.11\times0^{-4}$
and 14443 AND gates achieving maximum absolute error of $5.6\times10^{-8}$. In fact, our implementation support arbitrary 
trade off between precision and speed, however, we only showed two cases for the convenience of testing.

\paragraph{Code used for Task1b.}
Here we also include the code used for Task1b written in {\tt ObliVM-lang}.
\begin{figure}[H]
\begin{tabular}{rl}
\small 1&\small \tt \struct Task1bAutomated\at{n}\{\};\\
\small 2&\small \tt float32[\public n] Task1bAutomated\at{n}.\func{func}(\\
\small 3&\small \tt \quad      float32[\public n][\public 3] alice\_case, float32[\public n][\public 3] alice\_control,\\
\small 4&\small \tt  \quad     float32[\public n][\public 3] bob\_case, float32[\public n][\public 3] bob\_control) \{\\
\small 5&\small \tt \quad   float32[\public n] ret;\\
\small 6&\small \tt  \quad  \for(\public int32 i = 0; i < n; i = i + 1) \{\\
\small 7&\small \tt     \quad \quad  float32 a = alice\_case[i][0] + bob\_case[i][0];\\
\small 8&\small \tt     \quad \quad  float32 b = alice\_case[i][1] + bob\_case[i][1];\\
\small 9&\small \tt     \quad \quad  float32 c = alice\_control[i][0] + bob\_control[i][0];\\
\small 10&\small \tt    \quad \quad   float32 d = alice\_control[i][1] + bob\_control[i][1];\\
\small 11&\small \tt    \quad \quad   float32 g = a + c, k = b + d;\\
\small 12&\small \tt    \quad \quad   float32 tmp = a*d - b*c;\\
\small 13&\small \tt     \quad \quad  tmp = tmp*tmp;\\
\small 14&\small \tt     \quad \quad  ret[i] = tmp / (g * k);\\
\small 15&\small \tt   \quad  \}\\
\small 16&\small \tt  \quad  \return ret;\\
\small 17&\small \tt\}\\
\end{tabular}
\end{figure}
