\section{Task 1}
\subsection*{Task 1a: Computing Minor Allele Frequencies}
The problem of computing Minor Allele Frequencies(MAF) can be abstracted as follows:

Suppose Alice and Bob have list of alleles $l^a = (e^a_1,...,e^a_n)$ and $l^b = (e^b_1,...,e^b_n)$ respectively.
Let's append $l^b$ to $l^a$ and get $l = l^a || l^b$. It is publicly known that $l$ contains at most two types of
alleles from $(A,T,C,G)$. We want to compute the frequency of allele in $l$ that appears less frequently.

\paragraph{Our Solution}
The two parties first aggregate their own inputs into two numbers: $(f^a_1, f^a_2)$ for Alice and $(f^b_1,f^b_2)$ for Bob, ordered by allele type.
Then, in the secure computation, the two parties first aggregate the frequency by
$$(f_1, f_2) = (f^a_1+f^a_1, f^b_2+f^b_2),$$
and then report the smaller number between $f_1$ and $f_2$

For this task, each test case requires only 40 AND gates for both manually generated circuits and automatically generated circuits.

%\paragraph{Code used for Task1a.}
The code used for this task is shown in Figure~\ref{fig:lang-circuit-oram}.
%Here we also include the code used for Task 1a written in {\tt ObliVM-lang}.
\begin{figure}[H]
\begin{tabular}{rl}
\small 1&\small \tt	\struct Task1aAutomated\at{m}\{\};\\
\small 2&\small \tt	void Task1aAutomated\at{m}.\func{funct}(int\at{m}[\public 1] alice\_data, int\at{m}[\public 1] bob\_data,\\
\small 3&\small \tt	\quad      int\at{m}[\public 1] ret, \public int\at{m} total\_instances, \public int32 test\_cases) \{\\
\small 4&\small \tt	\quad   int\at{m} total = total\_instances;\\
\small 5&\small \tt	  \quad int\at{m} half = total\_instances / 2;\\
\small 6&\small \tt	 \quad  \for(\public int32 i = 0; i < test\_cases; i = i + 1) \{\\
\small 7&\small \tt	     \quad\quad ret[i] = alice\_data[i] + bob\_data[i];\\
\small 8&\small \tt	     \quad\quad \ifs(ret[i] > half)\\
\small 9&\small \tt	         \quad\quad\quad ret[i] = total - ret[i];\\
\small 10&\small \tt	  \quad \}\\
\small 11&\small \tt\}\\
\end{tabular}
\caption{Code for Task 1a written in {\tt ObliVM-lang}}
\label{fig:lang-circuit-oram}
\end{figure}


\subsection*{Task 1b: Computing $\chi$ square statistics}
%The problem can be abstracted as follows:
For this problem, the two parties want to compute the following:
$$n\times\frac{(ad-bc)^2}{rsgk},$$
where $r = a + b, s = c + d, g = a + c, k = b + d, n =  r + s$; and $a,b,c,d$ are additively secret shared by two parties.

\paragraph{Our Solution}
%At a high level, 
We take a direct approach: We first add shares from two parties and get $a,b,c,d,r,s,g,k$
and then convert it into floating point numbers. We then compute the function mentioned above.
All of this computation is performed using secure computation.
% using floating
%point numbers securely.

%<<<<<<< HEAD
Our implementation for this task supports an arbitrary 
trade off between precision and speed. We mention two specific cases here.
For each test case, an implementation that requires 7763 AND gates achieves a maximum absolute error of $1.11\times10^{-4}$
 and an implementation with 14443 AND gates achieves a maximum absolute error of $5.6\times10^{-8}$.
%=======
%For this task, each test case only requires 7763 AND gates achieving maximum absolute error of $1.11\times10^{-4}$
%and 14443 AND gates achieving maximum absolute error of $5.6\times10^{-8}$. In fact, our implementation support arbitrary 
%trade off between precision and speed, however, we only showed two cases for the convenience of testing.
%>>>>>>> 86d28b2f1fe701b0a6aed18d764428f85e961095

The code used for this task is shown in Figure~\ref{fig:task1b}.
%\paragraph{Code used for Task1b.}
%Here we also include the code used for Task1b written in {\tt ObliVM-lang}.
\begin{figure}[H]
\begin{tabular}{rl}
\small 1&\small \tt \struct Task1bAutomated\at{n}\{\};\\
\small 2&\small \tt float32[\public n] Task1bAutomated\at{n}.\func{func}(\\
\small 3&\small \tt \quad      float32[\public n][\public 3] alice\_case, float32[\public n][\public 3] alice\_control,\\
\small 4&\small \tt  \quad     float32[\public n][\public 3] bob\_case, float32[\public n][\public 3] bob\_control) \{\\
\small 5&\small \tt \quad   float32[\public n] ret;\\
\small 6&\small \tt  \quad  \for(\public int32 i = 0; i < n; i = i + 1) \{\\
\small 7&\small \tt     \quad \quad  float32 a = alice\_case[i][0] + bob\_case[i][0];\\
\small 8&\small \tt     \quad \quad  float32 b = alice\_case[i][1] + bob\_case[i][1];\\
\small 9&\small \tt     \quad \quad  float32 c = alice\_control[i][0] + bob\_control[i][0];\\
\small 10&\small \tt    \quad \quad   float32 d = alice\_control[i][1] + bob\_control[i][1];\\
\small 11&\small \tt    \quad \quad   float32 g = a + c, k = b + d;\\
\small 12&\small \tt    \quad \quad   float32 tmp = a*d - b*c;\\
\small 13&\small \tt     \quad \quad  tmp = tmp*tmp;\\
\small 14&\small \tt     \quad \quad  ret[i] = tmp / (g * k);\\
\small 15&\small \tt   \quad  \}\\
\small 16&\small \tt  \quad  \return ret;\\
\small 17&\small \tt\}\\
\end{tabular}
\caption{Code for Task 1b written in {\tt ObliVM-lang}}
\label{fig:task1b}
\end{figure}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
